# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 - 2019, Armin Ronacher
# This file is distributed under the same license as the Flask-SQLAlchemy
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask-SQLAlchemy 2.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-09 11:38+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../contexts.rst:6
msgid "Introduction into Contexts"
msgstr "컨텍스트에 대한 소개"

#: ../../contexts.rst:8
msgid ""
"If you are planning on using only one application you can largely skip "
"this chapter.  Just pass your application to the :class:`SQLAlchemy` "
"constructor and you're usually set.  However if you want to use more than"
" one application or create the application dynamically in a function you "
"want to read on."
msgstr ""
"만약 애플리케이션을 하나만 쓸 계획이면 이 장은 건너뛰어도 된다. "
"보통 하듯이 애플리케이션을 :class:`SQLAlchemy` 생성자에 인수로 넣는 것으로 충분하다. "
"하지만 두 개 이상의 애플리케이션을 사용하거나 함수 안에서 동적으로 애플리케이션을 "
"생성하고자 할 때는 이 장을 읽어야 한다."

#: ../../contexts.rst:14
msgid ""
"If you define your application in a function, but the :class:`SQLAlchemy`"
" object globally, how does the latter learn about the former?  The answer"
" is the :meth:`~SQLAlchemy.init_app` function::"
msgstr ""
"만약 함수 안에서 애플리케이션을 정의하면서 :class:`SQLAlchemy` 객체는 전역으로 "
"만들고 싶으면 전역 객체가 애플리케이션에 어떻게 접근하는가? "
"답은 :meth:`~SQLAlchemy.init_app` 함수이다.::"

#: ../../contexts.rst:29
msgid ""
"What it does is prepare the application to work with :class:`SQLAlchemy`."
"  However that does not now bind the :class:`SQLAlchemy` object to your "
"application.  Why doesn't it do that? Because there might be more than "
"one application created."
msgstr ""
"이 함수는 애플리케이션이 :class:`SQLAlchemy` 객체와 같이 일할 수 있도록 "
"준비시킨다. 하지만 :class:`SQLAlchemy` 객체를 애플리케이션에 바인드시키지는 않는다 "
"왜냐하면 다른 애플리케이션을 또 생성할 수도 있기 때문이다."

#: ../../contexts.rst:34
msgid ""
"So how does :class:`SQLAlchemy` come to know about your application? You "
"will have to setup an application context.  If you are working inside a "
"Flask view function or a CLI command, that automatically happens. "
"However, if you are working inside the interactive shell, you will have "
"to do that yourself (see `Creating an Application Context "
"<http://flask.pocoo.org/docs/appcontext/#creating-an-application-"
"context>`_)."
msgstr ""
"그러면 :class:`SQLAlchemy` 객체는 어떻게 애플리케이션에 대한 정보를 가지고 있을까? "
"이를 위해 애플리케이션 컨텍스트를 만들어야 한다. "
"만약 플라스크 뷰 함수나 명령줄 명령으로 작업하는 경우에는 컨텍스트가 자동으로 "
"만들어진다. 하지만 대화형 셸 내에서 작업할 때는 사용자가 직접 컨텍스트를 "
"만들어야 한다. (`애플리케이션 컨텍스트 생성 <http://flask.pocoo.org/docs/appcontext/#creating-an-application-context>`_ 참조)

#: ../../contexts.rst:41
msgid ""
"If you try to perform database operations outside an application context,"
" you will see the following error:"
msgstr ""

#: ../../contexts.rst:44
msgid ""
"No application found. Either work inside a view function or push an "
"application context."
msgstr ""

#: ../../contexts.rst:47
msgid "In a nutshell, do something like this:"
msgstr ""

#: ../../contexts.rst:53
msgid "Alternatively, use the with-statement to take care of setup and teardown::"
msgstr ""

#: ../../contexts.rst:61
msgid ""
"Some functions inside Flask-SQLAlchemy also accept optionally the "
"application to operate on:"
msgstr ""

